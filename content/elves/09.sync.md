---
title: 'Les √©changes'
date: 2025-04-30
weight: 90
tags: ['devel', 'elf', 'sync']
pre: '<b>3.9 </b>'
---

> ¬´ Dans les terres sauvages d'Azeroth, m√™me les plus puissants chamans savent
> que la force r√©side dans l'harmonie des √©l√©ments. Chaque guerrier agit de
> mani√®re autonome, mais tous sont pr√™ts √† s'unir pour former un tout
> indivisible, synchronisant leurs actions avec la pr√©cision d'une horde en
> marche. ¬ª
>
> ‚Äî Thrall, Chef de Guerre de la Horde

La synchronisation est un m√©canisme d'√©change d'√©tats entre un client et un
serveur. L'objectif √©tant qu'√† la fin, le serveur et tous les clients aient les
m√™mes √©tats pour tous les acteurs participants √† la synchronisation. Ici on
parle d'une architecture distribu√©e o√π chaque participant est une copie du
serveur de r√©f√©rence.

Les √©tats proviennent des acteurs du syst√®me. On utilise (dans notre syst√®me)
g√©n√©ralement un jargon comme goblin ou elf. Dans les deux cas, on peut
simplement parler d'acteurs (pas un acteur comme Orlando Bloom, bien qu‚Äôil soit
possible de faire des analogies). Les acteurs qui nous int√©ressent sont des
entit√©s qui ont un √©tat qui doit √™tre partag√© avec tout le monde.

Un acteur encapsule un √©tat et un comportement. Les communications entre les
acteurs sont toujours asynchrones en envoyant et en recevant des messages avec
uniquement du contenu s√©rialisable.

Prenons Yeti (un logiciel de gestion de demandes, tickets, ...), ce logiciel a
de nombreux acteurs comme par exemple les demandes. Une demande est un acteur de
type Elf, qui a un √©tat s√©rialisable (persistant). Dans notre jargon interne on
parle d'[Archetype][1]. Ici il faut simplement se dire que c'est un acteur qui
contient des informations sauvegard√©es sur l'ordinateur local. Quand le
programme est arr√™t√©, les donn√©es de l'acteur ne sont pas perdues. C‚Äôest tr√®s
important car il existe aussi les acteurs de type Spirit qui peuvent exister
uniquement quand le programme est en cours de fonctionnement (volatile).

## ü•ñ Local first

L'architecture est donc distribu√©e. Chaque client a localement les contenus de
tous les acteurs. Le programme peut fonctionner sans connexion r√©seau. C'est le
cas avec Yeti o√π toutes les fonctionnalit√©s qui ne d√©pendent pas de services
externes, sont disponibles m√™me si le serveur Yeti n'est pas joignable. On parle
alors de local-first car avant tout, les donn√©es sont manipul√©es localement et
ensuite (si possible) elles sont transmises √† (dans notre cas) un serveur. Par
exemple, Git est une application local-first typique.

![](/img/elf.local-first.png)

## üåê Le partage

Pour partager les donn√©es il existe de nombreuses architectures. Ici je vais
vous pr√©senter les m√©caniques qui ont √©t√© mises en place avec les Elfes.
L'infrastructure est assez classique. Il y a des clients et un serveur. Les
clients sont tous identiques et fonctionnent en local-first. Le serveur est
diff√©rent car il sert de r√©f√©rence pour les clients. N√©anmoins il partage la
plupart des m√™mes acteurs que les clients tout est √©tant plus l√©ger car il ne
contient pas les acteurs d√©di√©s √† l'interface graphique (ceci dit il peut
contenir des acteurs sp√©cifiques au serveur).

## üìÄ Les √©tats

Les √©tats (ou "states" en anglais) sont simplement les donn√©es de l'acteur. Par
exemple, avec une demande Yeti (qui est un acteur), on y trouve une description
et une liste de t√¢ches (je simplifie pour l'exemple). La description est
sauvegard√©e (persist√©e) sur l'ordinateur tout comme la liste des t√¢ches (ici les
t√¢ches sont aussi des acteurs, mais restons simple). L'√©tat complet est
sauvegard√© dans une base de donn√©es SQLite, qui ressemble un peu √† cela :

| actions   |
| --------- |
| - id      |
| - type    |
| - payload |

(Cette table est simplifi√©e pour aider √† la compr√©hension du m√©canisme.) Il y a
l'identifiant de l'acteur, le type d'action et les donn√©es de l'action.

Actions ? Mais de quoi parle-t-on ?¬†‚ö†Ô∏è

## üìà Les actions

Pour comprendre les actions, je dois d√©tailler un peu plus les "Elf" (acteurs).
Ceux-ci sont constitu√©s de deux parties bien visibles : il y a [les qu√™tes et
les reducers][2].

Les qu√™tes sont les APIs de l'acteur. Pour faire quelque chose avec l'acteur, il
faut lui appeler une qu√™te. Par exemple, avec les demandes Yeti, on peut
imaginer une qu√™te qui se nomme `close` et qui permet de fermer la demande.
Fermer une demande doit changer le statut de celle-ci puis envoyer un mail
(c'est un exemple).

![](/img/elf.actions.png)

La qu√™te `close` fait deux choses :

1. Elle demande √† son reducer de changer le statut.
2. Elle envoie un mail (plus pr√©cis√©ment, elle demande √† un autre acteur
   d'envoyer un mail).

L'√©tape une est dites pure car les reducers sont des fonctions pures. Ce qui
veut dire que pour un m√™me √©tat et de m√™me param√®tres, le reducer rendra
toujours un m√™me nouvel √©tat. Les reducers sont pr√©dictibles.

L'√©tape deux montre que les qu√™tes ne sont pas pures car elles peuvent avoir des
effets de bord. Ici l'effet de bord est de faire appel √† un autre acteur pour
envoyer un mail. Cette √©tape n'est pas pr√©visible car peut √™tre qu'il est
impossible d'envoyer le mail.

Je ne vais pas m'attarder plus longtemps sur les effets de bord. Ce qui nous
int√©resse ici est avant tout la modification de l'√©tat de l'acteur avec le
reducer.

Ici, la qu√™te `close` a un reducer du m√™me nom. Quand ce reducer est appel√©, un
champ "status" est modifi√© en "closed". Cette op√©ration passe par m√©canisme qui
suit le pattern d'architecture flux (que je ne vais pas d√©tailler ici).

L'appel du reducer `close` commence par la cr√©ation d'une action (ce que je
d√©cris ici, c'est de la m√©canique non-visible pour celui qui d√©veloppe un Elf).
Une action est compos√©e principalement de trois attributs :

```json
{
  "type": "close",
  "payload": {},
  "meta": {}
}
```

Int√©ressons-nous aux attributs `type` et `payload`. Le type permet de faire la
distinction entre tous les reducers de l'acteur. Le payload contient les donn√©es
**s√©rialisables** que l'on souhaite donner au reducer. Dans l'exemple du
`close`, il n'y a pas de payload particulier √† transmettre car le type de
l'action suffit.

Ci-dessus, j'ai mis en √©vidence "s√©rialisable" car de telles actions doivent
pouvoir √™tre enregistr√©es dans une base de donn√©es.

## üß™ Middlewares

Nous avons donc une action qui a bascul√© un statut sur 'closed'. Mais nous
sommes encore loin de pouvoir synchroniser quoi que ce soit. Ici, je vais
bri√®vement aborder les middlewares. L'id√©e est assez simple, un middleware peut
se mettre au milieu d'un flux.

Dans notre cas, on peut injecter un middleware dans le flux d'actions pour (par
exemple) envoyer une copie de l'action √† une base de donn√©es. Ceci permet √†
notre action `close` d'exister sous la forme s√©rialis√©e dans notre base de
donn√©es SQLite. L'id√©e est simple : si j'ai l'action, il me suffit de la jouer √†
nouveau pour reconstruire l'√©tat d'un acteur. Maintenant vous avez une des
briques essentielles de la synchronisation. Un middleware r√©cup√®re toutes les
actions de tous les acteurs s√©rialisables et les stock dans une (ou des) base(s)
de donn√©es SQLite.

Comprenez bien que ce m√©canisme est utile pour la synchronisation mais qu'il
existe avant tout pour g√©rer la persistance localement de tous les acteurs.

![](/img/elf.pipes.png)

## ü™ü Actions store

Nos bases de donn√©es sont des actions stores. Chaque mutation de l'√©tat d'un
acteur va toujours provoquer l'insertion de la dite action comme expliqu√©
pr√©c√©demment.

Ce qui veut dire que les actions stores ne font pas que conserver l'√©tat de
chaque acteur, mais ils conservent tous les √©tats dans le temps. L'axe temporel
offre de nombreux avantages. Il permet de comprendre comment √©volue un acteur,
il offre un moyen pour retrouver des contenus pr√©c√©dents (par exemple pour
offrir des outils d'¬´ annulation ¬ª √† l'√©dition). Cet axe temporel est √©galement
indispensable pour le m√©canisme de synchronisation.

> L'axe temporel n'est pas repr√©sent√© par un timestamp, mais uniquement par un
> compteur qui s'incr√©mente √† chaque insertion.

## üí± Les transactions

Revenons √† notre exemple de la demande sur laquelle nous appelons la qu√™te
`close`. Il manque encore quelque chose d'essentiel. Cette action ne fait rien
de plus que de dire qu'il faut changer le statut. Bien, mais cette action ne
contient aucune donn√©e. Elle a un `type` et `payload` est un objet vide. En
gardant cette action dans l'actions store, on ne conna√Æt pas du tout l'√©tat de
l'acteur. C'est simplement parce que je n'ai pas abord√© la question des
transactions. Ici, il n'est pas question de discuter des transactions SQL qui
concernent la couche SQLite. Les transactions de l'actions store sont plus haut
niveau et voici comment cela fonctionne.

Il existe des types particuliers d'actions qui se nomment `create` et `persist`.

Ces deux types d'action sont r√©serv√©s aux usages suivants :

- **create** : naissance d'une entit√©
- **persist** : instantan√© d'une entit√©

Lorsqu'un acteur utilise un identifiant nouveau dans l'application (par exemple
une nouvelle demande Yeti), un reducer `create` va √™tre appel√© pour donner
naissance √† cet acteur. Ce `create` ne peut pas √™tre appel√© plus d'une fois par
identifiant d'acteur. C'est l'action qui va donner l'√©tat initial de l'acteur.
N√©anmoins, comme pour l'action `close`, le payload ne contient pas l'√©tat
complet de ce nouvel acteur.

La seconde action, par contre, est plus int√©ressante. C'est une action de fin de
transaction car elle est la seule action √† contenir l'instantan√© de l'√©tat de
l'acteur.

Voici un exemple pour bien comprendre de quoi on parle.

| ‚Üì   | Type    | Description          |
| --- | ------- | -------------------- |
| 0   | create  | d√©but de transaction |
| 1   | persist | fin de transaction   |
| 2   | change  | d√©but                |
| 3   | change  | ‚Ä¶                    |
| 4   | persist | fin                  |
| 5   | close   | d√©but                |
| 6   | persist | fin                  |

Les actions qui ne sont pas de type `persist` permettent de modifier l'√©tat de
l'acteur. Tant qu'il n'y a pas de `persist`, la transaction est ouverte.
L'action `persist` prend l'√©tat m√©moire de l'acteur et sans le modifier. Dans la
base de donn√©e, pour chaque `persist` on y trouve l'√©tat complet en tant que
`payload`.

C'est tr√®s important de bien comprendre cette m√©canique. Quand un acteur est
mont√© dans l'application, son √©tat en m√©moire va √™tre nourri par le contenu du
dernier `persist` connu, le concernant. Quand on a termin√© de modifier l'√©tat
d'un acteur, il faut explicitement demander la g√©n√©ration de l'action `persist`.
Ainsi on ferme la transaction.

![](/img/elf.banker.png)

## ‚ôªÔ∏è Synchroniser

Nous en savons assez d√©sormais pour attaquer le sujet principal de cet expos√©.
Comment exploiter tout cela pour synchroniser les √©tats entre les clients et le
serveur ?

L'id√©e g√©n√©rale est relativement simple. Ceci dit, m√™me si l'id√©e est simple, la
r√©alisation devient complexe d√®s le moment o√π on introduit la gestion d'erreur
comme par exemple, comment retomber sur ces pattes en cas de crash aux
diff√©rentes √©tapes de la synchronisation.

Restons-en √† l'id√©e g√©n√©rale o√π aucun crash n'est possible et o√π le serveur ne
peut pas ne pas √™tre joignable.

Au commencement il y a le bootstrap.

![](/img/elf.synchronize.png)

1. Le client n'a encore jamais eu de synchronisation avec le serveur.
2. Le client donne son identifiant de commit le plus r√©cent qu'il a au serveur
   s'il en a au moins un.

Le serveur ‚Ä¶

‚õî **STOP**¬†‚õî

√Ä peine commenc√©, il y a un nouvel aspect que l'on n'a pas encore abord√©.

Ce sont les identifiants de commit. En effet, ils n'ont pas √©t√© abord√© car ils
n'ont aucune utilit√© quand le logiciel fonctionne seul (sans serveur de
r√©f√©rence). Ici, il ne faut pas comparer les identifiants de commit avec ceux de
Git. Dans Git, l'identifiant est calcul√© par somme (avec l'aide d'une fonction
de hashage) de l'ensemble de l'information contenu dans le commit (en-t√™te et
contenu). Dans notre cas, un identifiant de commit n'est rien de plus qu'un UUID
v4.

Les identifiants de commit sont g√©n√©r√©s par le serveur pour chaque
synchronisation. Avec ces identifiants il est possible de savoir depuis quand
remonte la derni√®re synchronisation, afin de traiter uniquement ce qui est
nouveau.

Ainsi, quand le client ne donne aucun commit ID alors il va √™tre n√©cessaire de
tout lui envoyer. C'est ce qui se nomme ici le bootstrap.

Continuons o√π on s'√©tait arr√™t√© :

1. Le client n'a pas de commit ID.
2. Le serveur lui retourne un stream de "row" SQL que le client ins√®re
   directement dans la base de donn√©es.

Dans ce sc√©nario, le client ne donne rien au serveur et la base de donn√©es
locale est vide. Le stream SQL est un lot de toutes les derni√®res actions
`persist` connues par le serveur. Toutes ces actions ont un ID de commit
associ√©.

Nous pouvons compl√©ter notre petit mod√®le de la base de donn√©es :

| actions   |
| --------- |
| - id      |
| - type    |
| - payload |
| - commit  |

Chaque action peut √™tre associ√©e √† un ID de commit provenant du serveur.

![](/img/elf.shopping.png)

Le bootstrap est termin√©, l'application se d√©bloque. Imaginons que nous
modifions la description d'une demande. Voyons chaque √©tape (actions store)
jusqu'√† la fin de la synchronisation .

| id         | type    | payload | commit |
| ---------- | ------- | ------- | ------ |
| demande 42 | persist | {‚Ä¶}     | abcd   |

On modifie :

|            |        |        |      |
| ---------- | ------ | ------ | ---- |
| demande 42 | change | {bli‚Ä¶} | null |

Encore :

|            |        |        |      |
| ---------- | ------ | ------ | ---- |
| demande 42 | change | {bla‚Ä¶} | null |

On a modifi√© deux fois la demande. Que se passe-t-il avec la synchronisation ?

‚Üí Rien du tout‚Ä¶ ici la transaction est toujours ouverte. Pour fermer la
transaction, il nous faut une action `persist`. Et seulement √† ce moment-l√†, il
est envisageable de d√©marrer une synchronisation.

| id         | type    | commit |                      |
| ---------- | ------- | ------ | -------------------- |
| demande 42 | persist | abcd   | connu par le serveur |
| demande 42 | change  | null   |                      |
| demande 42 | change  | null   |                      |
| demande 42 | persist | null   | fin de transaction   |

On peut imaginer plusieurs acteurs :

| id         | type    | commit |                       |
| ---------- | ------- | ------ | --------------------- |
| t√¢che 84   | persist | efgh   | connu par le serveur  |
| demande 42 | persist | abcd   | connu par le serveur  |
| demande 42 | change  | null   |                       |
| demande 42 | change  | null   |                       |
| t√¢che 84   | close   | null   |                       |
| demande 42 | persist | null   | fin de transaction 42 |
| t√¢che 84   | persist | null   | fin de transaction 84 |

> Une m√™me base de donn√©e va abriter diff√©rents types d'acteurs en m√™me temps.

Le client va d√©marrer une synchronisation. Il va chercher toutes les actions
non-persist puis il va les envoyer au serveur.

| id         | type    | commit |                     |
| ---------- | ------- | ------ | ------------------- |
| t√¢che 84   | persist | efgh   |                     |
| demande 42 | persist | abcd   |                     |
| demande 42 | change  | null   | actions non-persist |
| demande 42 | change  | null   | actions non-persist |
| t√¢che 84   | close   | null   | actions non-persist |
| demande 42 | persist | null   |                     |
| t√¢che 84   | persist | null   |                     |

Pour pr√©parer l'envoi, le client pr√©pare les actions avec des ID de commit √† 0.

| id         | type   | commit |
| ---------- | ------ | ------ |
| demande 42 | change | 0000   |
| demande 42 | change | 0000   |
| t√¢che 84   | close  | 0000   |

Le serveur re√ßoit ces actions, et les joue dans ses reducers (et non les qu√™tes,
car ici on ne veut surtout pas d'effets de bord).

Cette √©tape va provoquer la cr√©ation de deux actions `persist` (on est toujours
du c√¥t√© du serveur). Un identifiant de commit est g√©n√©r√© pour ce lot.

Sur le serveur :

| id         | type    | commit |                  |
| ---------- | ------- | ------ | ---------------- |
| demande 42 | change  | null   |                  |
| demande 42 | change  | null   |                  |
| t√¢che 84   | close   | null   |                  |
| demande 42 | persist | 4444   | √©tats d√©finitifs |
| t√¢che 84   | persist | 4444   | √©tats d√©finitifs |

Tous les `persist` sont alors retourn√©s au client qui va les ins√©rer dans sa
base de donn√©es.

Les actions non-persist √† `0000` sont alors mises √† jour avec le commit ID.

| id         | type    | commit |
| ---------- | ------- | ------ |
| t√¢che 84   | persist | efgh   |
| demande 42 | persist | abcd   |
| demande 42 | change  | 4444   |
| demande 42 | change  | 4444   |
| t√¢che 84   | close   | 4444   |
| demande 42 | persist | null   |
| t√¢che 84   | persist | null   |
| demande 42 | persist | 4444   |
| t√¢che 84   | persist | 4444   |

Voici ce que les clients obtiennent en fin de synchronisation. Les actions
`persist` du serveur viennent surcharger celles que le client a cr√©√©es
localement. Voyons ce que cela donne pour un client qui n'est pas √† la source
des modifications :

| id         | type    | commit |
| ---------- | ------- | ------ |
| t√¢che 84   | persist | efgh   |
| demande 42 | persist | abcd   |
| demande 42 | persist | 4444   |
| t√¢che 84   | persist | 4444   |

La synchronisation d'actions non-persists m√®ne √† une fusion c√¥t√© serveur. C'est
un peu comme envoyer des deltas, mais ici on envoie des actions qui d√©crivent ce
qui doit changer. Pour terminer, le serveur g√©n√®re le nouvel instantan√©
`persist` √† envoyer √† tous les clients.

Quand le serveur termine le traitement d'un lot d'actions pour un acteur, et
avant de g√©n√©rer l'action `persist`, il va appeler la qu√™te
"beforePersistOnServer" si celle-ci existe pour l'acteur en question. Cette
qu√™te permet d'effectuer des effets de bords sp√©cifiques au serveur, et (ou) d'y
effectuer des modifications de l'√©tat si n√©cessaire. C'est ainsi la seule qu√™te
qui peut √™tre ex√©cut√©e lors d'une synchronisation.

## ‚õëÔ∏è Faire une bonne action

L‚Äô√©criture des reducers demande de faire un petit peu attention √† ce qui peut se
passer lors d‚Äôune fusion sur le serveur. Faire une bonne action c‚Äôest faire des
actions qui sont granulaires. Prennons l‚Äôexemples d‚Äôune liste, telle que la
liste des t√¢ches d‚Äôune demande.

![](/img/elf.doctor.png)

Imaginons une impl√©mentation incorrecte :

```js
/* qu√™te */
liste_des_t√¢ches = √©tat.liste_des_t√¢ches;
liste_des_t√¢ches.ajoute(la_nouvelle_t√¢che);
appel_le_reducer(liste_des_t√¢ches);

/* Reducer argument: liste_des_t√¢ches */
√©tat.liste_des_t√¢ches = liste_des_t√¢ches;
```

Dans cet exemple nous avons une qu√™te qui va r√©cup√©rer la liste des t√¢ches
depuis l‚Äô√©tat de son acteur, ajouter une t√¢che dans la liste et donner la
nouvelle liste au reducer. Cette impl√©mentation pose deux probl√®mes.

1. Depuis une qu√™te, on ne devrait jamais chercher √† modifier un √©tat, mais
   uniquement le lire
2. L‚Äôappel du reducer prend la liste enti√®re en param√®tre

La cons√©quence de cette impl√©mentation est que l‚Äôaction qui va √™tre jou√©e sur le
serveur, va compl√®tement remplacer la liste pr√©c√©dente par une nouvelle qui a
√©t√© calcul√©e depuis le client. Il n‚Äôy a donc pas de fusion pour cette liste, car
le dernier √† synchroniser impose sa v√©rit√©.

Voici une impl√©mentation correcte :

```js
/* qu√™te */
appel_le_reducer(la_nouvelle_t√¢che);

/* Reducer argument: la_nouvelle_t√¢che */
√©tat.liste_des_t√¢ches.ajoute(la_nouvelle_t√¢che);
```

Dans ce second exemple, tout ce fusionne correctement car pour chaque
synchronisation il y a un ajout effectu√© dans le reducer et pas depuis la qu√™te.
Le serveur va alors effectivement fusionner l‚Äôajout des nouvelles t√¢ches
provenant de tous les clients.

[1]: /elves/08.grave
[2]: /elves/04.states
