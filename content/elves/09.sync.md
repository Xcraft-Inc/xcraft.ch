---
title: 'Les Ã©changes'
date: 2025-04-30
weight: 90
tags: ['devel', 'elf', 'sync']
pre: '<b>3.9 </b>'
---

> Â« Dans les terres sauvages d'Azeroth, mÃªme les plus puissants chamans savent
> que la force rÃ©side dans l'harmonie des Ã©lÃ©ments. Chaque guerrier agit de
> maniÃ¨re autonome, mais tous sont prÃªts Ã  s'unir pour former un tout
> indivisible, synchronisant leurs actions avec la prÃ©cision d'une horde en
> marche. Â»
>
> â€” Thrall, Chef de Guerre de la Horde

La synchronisation est un mÃ©canisme d'Ã©change d'Ã©tats entre un client et un
serveur. L'objectif Ã©tant qu'Ã  la fin, le serveur et tous les clients aient les
mÃªmes Ã©tats pour tous les acteurs participants Ã  la synchronisation. Ici on
parle d'une architecture distribuÃ©e oÃ¹ chaque participant est une copie du
serveur de rÃ©fÃ©rence.

Les Ã©tats proviennent des acteurs du systÃ¨me. On utilise (dans notre systÃ¨me)
gÃ©nÃ©ralement un jargon comme goblin ou elf. Dans les deux cas, on peut
simplement parler d'acteurs (pas un acteur comme Orlando Bloom, bien quâ€™il soit
possible de faire des analogies). Les acteurs qui nous intÃ©ressent sont des
entitÃ©s qui ont un Ã©tat qui doit Ãªtre partagÃ© avec tout le monde.

Un acteur encapsule un Ã©tat et un comportement. Les communications entre les
acteurs sont toujours asynchrones en envoyant et en recevant des messages avec
uniquement du contenu sÃ©rialisable.

Prenons Yeti (un logiciel de gestion de demandes, tickets, ...), ce logiciel a
de nombreux acteurs comme par exemple les demandes. Une demande est un acteur de
type Elf, qui a un Ã©tat sÃ©rialisable (persistant). Dans notre jargon interne on
parle d'[Archetype][1]. Ici il faut simplement se dire que c'est un acteur qui
contient des informations sauvegardÃ©es sur l'ordinateur local. Quand le
programme est arrÃªtÃ©, les donnÃ©es de l'acteur ne sont pas perdues. Câ€™est trÃ¨s
important car il existe aussi les acteurs de type Spirit qui peuvent exister
uniquement quand le programme est en cours de fonctionnement (volatile).

## ğŸ¥– Local first

L'architecture est donc distribuÃ©e. Chaque client a localement les contenus de
tous les acteurs. Le programme peut fonctionner sans connexion rÃ©seau. C'est le
cas avec Yeti oÃ¹ toutes les fonctionnalitÃ©s qui ne dÃ©pendent pas de services
externes, sont disponibles mÃªme si le serveur Yeti n'est pas joignable. On parle
alors de local-first car avant tout, les donnÃ©es sont manipulÃ©es localement et
ensuite (si possible) elles sont transmises Ã  (dans notre cas) un serveur. Par
exemple, Git est une application local-first typique.

![](/img/elf.local-first.png)

## ğŸŒ Le partage

Pour partager les donnÃ©es il existe de nombreuses architectures. Ici je vais
vous prÃ©senter les mÃ©caniques qui ont Ã©tÃ© mises en place avec les Elfes.
L'infrastructure est assez classique. Il y a des clients et un serveur. Les
clients sont tous identiques et fonctionnent en local-first. Le serveur est
diffÃ©rent car il sert de rÃ©fÃ©rence pour les clients. NÃ©anmoins il partage la
plupart des mÃªmes acteurs que les clients tout est Ã©tant plus lÃ©ger car il ne
contient pas les acteurs dÃ©diÃ©s Ã  l'interface graphique (ceci dit il peut
contenir des acteurs spÃ©cifiques au serveur).

## ğŸ“€ Les Ã©tats

Les Ã©tats (ou "states" en anglais) sont simplement les donnÃ©es de l'acteur. Par
exemple, avec une demande Yeti (qui est un acteur), on y trouve une description
et une liste de tÃ¢ches (je simplifie pour l'exemple). La description est
sauvegardÃ©e (persistÃ©e) sur l'ordinateur tout comme la liste des tÃ¢ches (ici les
tÃ¢ches sont aussi des acteurs, mais restons simple). L'Ã©tat complet est
sauvegardÃ© dans une base de donnÃ©es SQLite, qui ressemble un peu Ã  cela :

| actions   |
| --------- |
| - id      |
| - type    |
| - payload |

(Cette table est simplifiÃ©e pour aider Ã  la comprÃ©hension du mÃ©canisme.) Il y a
l'identifiant de l'acteur, le type d'action et les donnÃ©es de l'action.

Actions ? Mais de quoi parle-t-on ?Â âš ï¸

## ğŸ“ˆ Les actions

Pour comprendre les actions, je dois dÃ©tailler un peu plus les "Elf" (acteurs).
Ceux-ci sont constituÃ©s de deux parties bien visibles : il y a [les quÃªtes et
les reducers][2].

Les quÃªtes sont les APIs de l'acteur. Pour faire quelque chose avec l'acteur, il
faut lui appeler une quÃªte. Par exemple, avec les demandes Yeti, on peut
imaginer une quÃªte qui se nomme `close` et qui permet de fermer la demande.
Fermer une demande doit changer le statut de celle-ci puis envoyer un mail
(c'est un exemple).

![](/img/elf.actions.png)

La quÃªte `close` fait deux choses :

1. Elle demande Ã  son reducer de changer le statut.
2. Elle envoie un mail (plus prÃ©cisÃ©ment, elle demande Ã  un autre acteur
   d'envoyer un mail).

L'Ã©tape une est dites pure car les reducers sont des fonctions pures. Ce qui
veut dire que pour un mÃªme Ã©tat et de mÃªme paramÃ¨tres, le reducer rendra
toujours un mÃªme nouvel Ã©tat. Les reducers sont prÃ©dictibles.

L'Ã©tape deux montre que les quÃªtes ne sont pas pures car elles peuvent avoir des
effets de bord. Ici l'effet de bord est de faire appel Ã  un autre acteur pour
envoyer un mail. Cette Ã©tape n'est pas prÃ©visible car peut Ãªtre qu'il est
impossible d'envoyer le mail.

Je ne vais pas m'attarder plus longtemps sur les effets de bord. Ce qui nous
intÃ©resse ici est avant tout la modification de l'Ã©tat de l'acteur avec le
reducer.

Ici, la quÃªte `close` a un reducer du mÃªme nom. Quand ce reducer est appelÃ©, un
champ "status" est modifiÃ© en "closed". Cette opÃ©ration passe par mÃ©canisme qui
suit le pattern d'architecture flux (que je ne vais pas dÃ©tailler ici).

L'appel du reducer `close` commence par la crÃ©ation d'une action (ce que je
dÃ©cris ici, c'est de la mÃ©canique non-visible pour celui qui dÃ©veloppe un Elf).
Une action est composÃ©e principalement de trois attributs :

```json
{
  "type": "close",
  "payload": {},
  "meta": {}
}
```

IntÃ©ressons-nous aux attributs `type` et `payload`. Le type permet de faire la
distinction entre tous les reducers de l'acteur. Le payload contient les donnÃ©es
**sÃ©rialisables** que l'on souhaite donner au reducer. Dans l'exemple du
`close`, il n'y a pas de payload particulier Ã  transmettre car le type de
l'action suffit.

Ci-dessus, j'ai mis en Ã©vidence "sÃ©rialisable" car de telles actions doivent
pouvoir Ãªtre enregistrÃ©es dans une base de donnÃ©es.

## ğŸ§ª Middlewares

Nous avons donc une action qui a basculÃ© un statut sur 'closed'. Mais nous
sommes encore loin de pouvoir synchroniser quoi que ce soit. Ici, je vais
briÃ¨vement aborder les middlewares. L'idÃ©e est assez simple, un middleware peut
se mettre au milieu d'un flux.

Dans notre cas, on peut injecter un middleware dans le flux d'actions pour (par
exemple) envoyer une copie de l'action Ã  une base de donnÃ©es. Ceci permet Ã 
notre action `close` d'exister sous la forme sÃ©rialisÃ©e dans notre base de
donnÃ©es SQLite. L'idÃ©e est simple : si j'ai l'action, il me suffit de la jouer Ã 
nouveau pour reconstruire l'Ã©tat d'un acteur. Maintenant vous avez une des
briques essentielles de la synchronisation. Un middleware rÃ©cupÃ¨re toutes les
actions de tous les acteurs sÃ©rialisables et les stock dans une (ou des) base(s)
de donnÃ©es SQLite.

Comprenez bien que ce mÃ©canisme est utile pour la synchronisation mais qu'il
existe avant tout pour gÃ©rer la persistance localement de tous les acteurs.

![](/img/elf.pipes.png)

## ğŸªŸ Actions store

Nos bases de donnÃ©es sont des actions stores. Chaque mutation de l'Ã©tat d'un
acteur va toujours provoquer l'insertion de la dite action comme expliquÃ©
prÃ©cÃ©demment.

Ce qui veut dire que les actions stores ne font pas que conserver l'Ã©tat de
chaque acteur, mais ils conservent tous les Ã©tats dans le temps. L'axe temporel
offre de nombreux avantages. Il permet de comprendre comment Ã©volue un acteur,
il offre un moyen pour retrouver des contenus prÃ©cÃ©dents (par exemple pour
offrir des outils d'Â« annulation Â» Ã  l'Ã©dition). Cet axe temporel est Ã©galement
indispensable pour le mÃ©canisme de synchronisation.

> L'axe temporel n'est pas reprÃ©sentÃ© par un timestamp, mais uniquement par un
> compteur qui s'incrÃ©mente Ã  chaque insertion.

## ğŸ’± Les transactions

Revenons Ã  notre exemple de la demande sur laquelle nous appelons la quÃªte
`close`. Il manque encore quelque chose d'essentiel. Cette action ne fait rien
de plus que de dire qu'il faut changer le statut. Bien, mais cette action ne
contient aucune donnÃ©e. Elle a un `type` et `payload` est un objet vide. En
gardant cette action dans l'actions store, on ne connaÃ®t pas du tout l'Ã©tat de
l'acteur. C'est simplement parce que je n'ai pas abordÃ© la question des
transactions. Ici, il n'est pas question de discuter des transactions SQL qui
concernent la couche SQLite. Les transactions de l'actions store sont plus haut
niveau et voici comment cela fonctionne.

Il existe des types particuliers d'actions qui se nomment `create` et `persist`.

Ces deux types d'action sont rÃ©servÃ©s aux usages suivants :

- **create** : naissance d'une entitÃ©
- **persist** : instantanÃ© d'une entitÃ©

Lorsqu'un acteur utilise un identifiant nouveau dans l'application (par exemple
une nouvelle demande Yeti), un reducer `create` va Ãªtre appelÃ© pour donner
naissance Ã  cet acteur. Ce `create` ne peut pas Ãªtre appelÃ© plus d'une fois par
identifiant d'acteur. C'est l'action qui va donner l'Ã©tat initial de l'acteur.
NÃ©anmoins, comme pour l'action `close`, le payload ne contient pas l'Ã©tat
complet de ce nouvel acteur.

La seconde action, par contre, est plus intÃ©ressante. C'est une action de fin de
transaction car elle est la seule action Ã  contenir l'instantanÃ© de l'Ã©tat de
l'acteur.

Voici un exemple pour bien comprendre de quoi on parle.

| â†“   | Type    | Description          |
| --- | ------- | -------------------- |
| 0   | create  | dÃ©but de transaction |
| 1   | persist | fin de transaction   |
| 2   | change  | dÃ©but                |
| 3   | change  | â€¦                    |
| 4   | persist | fin                  |
| 5   | close   | dÃ©but                |
| 6   | persist | fin                  |

Les actions qui ne sont pas de type `persist` permettent de modifier l'Ã©tat de
l'acteur. Tant qu'il n'y a pas de `persist`, la transaction est ouverte.
L'action `persist` prend l'Ã©tat mÃ©moire de l'acteur et sans le modifier. Dans la
base de donnÃ©e, pour chaque `persist` on y trouve l'Ã©tat complet en tant que
`payload`.

C'est trÃ¨s important de bien comprendre cette mÃ©canique. Quand un acteur est
montÃ© dans l'application, son Ã©tat en mÃ©moire va Ãªtre nourri par le contenu du
dernier `persist` connu, le concernant. Quand on a terminÃ© de modifier l'Ã©tat
d'un acteur, il faut explicitement demander la gÃ©nÃ©ration de l'action `persist`.
Ainsi on ferme la transaction.

![](/img/elf.banker.png)

## â™»ï¸ Synchroniser

Nous en savons assez dÃ©sormais pour attaquer le sujet principal de cet exposÃ©.
Comment exploiter tout cela pour synchroniser les Ã©tats entre les clients et le
serveur ?

L'idÃ©e gÃ©nÃ©rale est relativement simple. Ceci dit, mÃªme si l'idÃ©e est simple, la
rÃ©alisation devient complexe dÃ¨s le moment oÃ¹ on introduit la gestion d'erreur
comme par exemple, comment retomber sur ces pattes en cas de crash aux
diffÃ©rentes Ã©tapes de la synchronisation.

Restons-en Ã  l'idÃ©e gÃ©nÃ©rale oÃ¹ aucun crash n'est possible et oÃ¹ le serveur ne
peut pas ne pas Ãªtre joignable.

Au commencement il y a le bootstrap.

![](/img/elf.synchronize.png)

1. Le client n'a encore jamais eu de synchronisation avec le serveur.
2. Le client donne son identifiant de commit le plus rÃ©cent qu'il a au serveur
   s'il en a au moins un.

Le serveur â€¦

â›” **STOP**Â â›”

Ã€ peine commencÃ©, il y a un nouvel aspect que l'on n'a pas encore abordÃ©.

Ce sont les identifiants de commit. En effet, ils n'ont pas Ã©tÃ© abordÃ© car ils
n'ont aucune utilitÃ© quand le logiciel fonctionne seul (sans serveur de
rÃ©fÃ©rence). Ici, il ne faut pas comparer les identifiants de commit avec ceux de
Git. Dans Git, l'identifiant est calculÃ© par somme (avec l'aide d'une fonction
de hashage) de l'ensemble de l'information contenu dans le commit (en-tÃªte et
contenu). Dans notre cas, un identifiant de commit n'est rien de plus qu'un UUID
v4.

Les identifiants de commit sont gÃ©nÃ©rÃ©s par le serveur pour chaque
synchronisation. Avec ces identifiants il est possible de savoir depuis quand
remonte la derniÃ¨re synchronisation, afin de traiter uniquement ce qui est
nouveau.

Ainsi, quand le client ne donne aucun commit ID alors il va Ãªtre nÃ©cessaire de
tout lui envoyer. C'est ce qui se nomme ici le bootstrap.

Continuons oÃ¹ on s'Ã©tait arrÃªtÃ© :

1. Le client n'a pas de commit ID.
2. Le serveur lui retourne un stream de "row" SQL que le client insÃ¨re
   directement dans la base de donnÃ©es.

Dans ce scÃ©nario, le client ne donne rien au serveur et la base de donnÃ©es
locale est vide. Le stream SQL est un lot de toutes les derniÃ¨res actions
`persist` connues par le serveur. Toutes ces actions ont un ID de commit
associÃ©.

Nous pouvons complÃ©ter notre petit modÃ¨le de la base de donnÃ©es :

| actions   |
| --------- |
| - id      |
| - type    |
| - payload |
| - commit  |

Chaque action peut Ãªtre associÃ©e Ã  un ID de commit provenant du serveur.

![](/img/elf.shopping.png)

Le bootstrap est terminÃ©, l'application se dÃ©bloque. Imaginons que nous
modifions la description d'une demande. Voyons chaque Ã©tape (actions store)
jusqu'Ã  la fin de la synchronisation .

| id         | type    | payload | commit |
| ---------- | ------- | ------- | ------ |
| demande 42 | persist | {â€¦}     | abcd   |

On modifie :

|            |        |        |      |
| ---------- | ------ | ------ | ---- |
| demande 42 | change | {bliâ€¦} | null |

Encore :

|            |        |        |      |
| ---------- | ------ | ------ | ---- |
| demande 42 | change | {blaâ€¦} | null |

On a modifiÃ© deux fois la demande. Que se passe-t-il avec la synchronisation ?

â†’ Rien du toutâ€¦ ici la transaction est toujours ouverte. Pour fermer la
transaction, il nous faut une action `persist`. Et seulement Ã  ce moment-lÃ , il
est envisageable de dÃ©marrer une synchronisation.

| id         | type    | commit |                      |
| ---------- | ------- | ------ | -------------------- |
| demande 42 | persist | abcd   | connu par le serveur |
| demande 42 | change  | null   |                      |
| demande 42 | change  | null   |                      |
| demande 42 | persist | null   | fin de transaction   |

On peut imaginer plusieurs acteurs :

| id         | type    | commit |                       |
| ---------- | ------- | ------ | --------------------- |
| tÃ¢che 84   | persist | efgh   | connu par le serveur  |
| demande 42 | persist | abcd   | connu par le serveur  |
| demande 42 | change  | null   |                       |
| demande 42 | change  | null   |                       |
| tÃ¢che 84   | close   | null   |                       |
| demande 42 | persist | null   | fin de transaction 42 |
| tÃ¢che 84   | persist | null   | fin de transaction 84 |

> Une mÃªme base de donnÃ©e va abriter diffÃ©rents types d'acteurs en mÃªme temps.

Le client va dÃ©marrer une synchronisation. Il va chercher toutes les actions
non-persist puis il va les envoyer au serveur.

| id         | type    | commit |                     |
| ---------- | ------- | ------ | ------------------- |
| tÃ¢che 84   | persist | efgh   |                     |
| demande 42 | persist | abcd   |                     |
| demande 42 | change  | null   | actions non-persist |
| demande 42 | change  | null   | actions non-persist |
| tÃ¢che 84   | close   | null   | actions non-persist |
| demande 42 | persist | null   |                     |
| tÃ¢che 84   | persist | null   |                     |

Pour prÃ©parer l'envoi, le client prÃ©pare les actions avec des ID de commit Ã  0.

| id         | type   | commit |
| ---------- | ------ | ------ |
| demande 42 | change | 0000   |
| demande 42 | change | 0000   |
| tÃ¢che 84   | close  | 0000   |

Le serveur reÃ§oit ces actions, et les joue dans ses reducers (et non les quÃªtes,
car ici on ne veut surtout pas d'effets de bord).

Cette Ã©tape va provoquer la crÃ©ation de deux actions `persist` (on est toujours
du cÃ´tÃ© du serveur). Un identifiant de commit est gÃ©nÃ©rÃ© pour ce lot.

Sur le serveur :

| id         | type    | commit |                  |
| ---------- | ------- | ------ | ---------------- |
| demande 42 | change  | null   |                  |
| demande 42 | change  | null   |                  |
| tÃ¢che 84   | close   | null   |                  |
| demande 42 | persist | 4444   | Ã©tats dÃ©finitifs |
| tÃ¢che 84   | persist | 4444   | Ã©tats dÃ©finitifs |

Tous les `persist` sont alors retournÃ©s au client qui va les insÃ©rer dans sa
base de donnÃ©es.

Les actions non-persist Ã  `0000` sont alors mises Ã  jour avec le commit ID.

| id         | type    | commit |
| ---------- | ------- | ------ |
| tÃ¢che 84   | persist | efgh   |
| demande 42 | persist | abcd   |
| demande 42 | change  | 4444   |
| demande 42 | change  | 4444   |
| tÃ¢che 84   | close   | 4444   |
| demande 42 | persist | null   |
| tÃ¢che 84   | persist | null   |
| demande 42 | persist | 4444   |
| tÃ¢che 84   | persist | 4444   |

Voici ce que les clients obtiennent en fin de synchronisation. Les actions
`persist` du serveur viennent surcharger celles que le client a crÃ©Ã©es
localement. Voyons ce que cela donne pour un client qui n'est pas Ã  la source
des modifications :

| id         | type    | commit |
| ---------- | ------- | ------ |
| tÃ¢che 84   | persist | efgh   |
| demande 42 | persist | abcd   |
| demande 42 | persist | 4444   |
| tÃ¢che 84   | persist | 4444   |

La synchronisation d'actions non-persists mÃ¨ne Ã  une fusion cÃ´tÃ© serveur. C'est
un peu comme envoyer des deltas, mais ici on envoie des actions qui dÃ©crivent ce
qui doit changer. Pour terminer, le serveur gÃ©nÃ¨re le nouvel instantanÃ©
`persist` Ã  envoyer Ã  tous les clients.

Quand le serveur termine le traitement d'un lot d'actions pour un acteur, et
avant de gÃ©nÃ©rer l'action `persist`, il va appeler la quÃªte
"beforePersistOnServer" si celle-ci existe pour l'acteur en question. Cette
quÃªte permet d'effectuer des effets de bords spÃ©cifiques au serveur, et (ou) d'y
effectuer des modifications de l'Ã©tat si nÃ©cessaire. C'est ainsi la seule quÃªte
qui peut Ãªtre exÃ©cutÃ©e lors d'une synchronisation.

## â›‘ï¸ Faire une bonne action

Lâ€™Ã©criture des reducers demande de faire un petit peu attention Ã  ce qui peut se
passer lors dâ€™une fusion sur le serveur. Faire une bonne action câ€™est faire des
actions qui sont granulaires. Prennons lâ€™exemples dâ€™une liste, telle que la
liste des tÃ¢ches dâ€™une demande.

![](/img/elf.doctor.png)

Imaginons une implÃ©mentation incorrecte :

```js
/* quÃªte */
liste_des_tÃ¢ches = Ã©tat.liste_des_tÃ¢ches;
liste_des_tÃ¢ches.ajoute(la_nouvelle_tÃ¢che);
appel_le_reducer(liste_des_tÃ¢ches);

/* Reducer argument: liste_des_tÃ¢ches */
Ã©tat.liste_des_tÃ¢ches = liste_des_tÃ¢ches;
```

Dans cet exemple nous avons une quÃªte qui va rÃ©cupÃ©rer la liste des tÃ¢ches
depuis lâ€™Ã©tat de son acteur, ajouter une tÃ¢che dans la liste et donner la
nouvelle liste au reducer. Cette implÃ©mentation pose deux problÃ¨mes.

1. Depuis une quÃªte, on ne devrait jamais chercher Ã  modifier un Ã©tat, mais
   uniquement le lire
2. Lâ€™appel du reducer prend la liste entiÃ¨re en paramÃ¨tre

La consÃ©quence de cette implÃ©mentation est que lâ€™action qui va Ãªtre jouÃ©e sur le
serveur, va complÃ¨tement remplacer la liste prÃ©cÃ©dente par une nouvelle qui a
Ã©tÃ© calculÃ©e depuis le client. Il nâ€™y a donc pas de fusion pour cette liste, car
le dernier Ã  synchroniser impose sa vÃ©ritÃ©.

Voici une implÃ©mentation correcte :

```js
/* quÃªte */
appel_le_reducer(la_nouvelle_tÃ¢che);

/* Reducer argument: la_nouvelle_tÃ¢che */
Ã©tat.liste_des_tÃ¢ches.ajoute(la_nouvelle_tÃ¢che);
```

Dans ce second exemple, tout ce fusionne correctement car pour chaque
synchronisation il y a un ajout effectuÃ© dans le reducer et pas depuis la quÃªte.
Le serveur va alors effectivement fusionner lâ€™ajout des nouvelles tÃ¢ches
provenant de tous les clients.

[1]: /elves/08.grave
[2]: /elves/04.states
